{
  "contractName": "IERC173",
  "sourceName": "solc_0.7/diamond/interfaces/IERC173.sol",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "bytecode": "0x",
  "deployedBytecode": "0x",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "devdoc": {
    "events": {
      "OwnershipTransferred(address,address)": {
        "details": "This emits when ownership of a contract changes."
      }
    },
    "kind": "dev",
    "methods": {
      "owner()": {
        "returns": {
          "_0": "The address of the owner."
        }
      },
      "transferOwnership(address)": {
        "details": "Set _newOwner to address(0) to renounce any ownership.",
        "params": {
          "_newOwner": "The address of the new owner of the contract"
        }
      }
    },
    "title": "ERC-173 Contract Ownership Standard  Note: the ERC-165 identifier for this interface is 0x7f5828d0",
    "version": 1
  },
  "evm": {
    "bytecode": {
      "linkReferences": {},
      "object": "",
      "opcodes": "",
      "sourceMap": ""
    },
    "deployedBytecode": {
      "immutableReferences": {},
      "linkReferences": {},
      "object": "",
      "opcodes": "",
      "sourceMap": ""
    },
    "gasEstimates": null,
    "methodIdentifiers": {
      "owner()": "8da5cb5b",
      "transferOwnership(address)": "f2fde38b"
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.7.1+commit.f4a555be\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"OwnershipTransferred(address,address)\":{\"details\":\"This emits when ownership of a contract changes.\"}},\"kind\":\"dev\",\"methods\":{\"owner()\":{\"returns\":{\"_0\":\"The address of the owner.\"}},\"transferOwnership(address)\":{\"details\":\"Set _newOwner to address(0) to renounce any ownership.\",\"params\":{\"_newOwner\":\"The address of the new owner of the contract\"}}},\"title\":\"ERC-173 Contract Ownership Standard  Note: the ERC-165 identifier for this interface is 0x7f5828d0\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"owner()\":{\"notice\":\"Get the address of the owner\"},\"transferOwnership(address)\":{\"notice\":\"Set the address of the new owner of the contract\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solc_0.7/diamond/interfaces/IERC173.sol\":\"IERC173\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2000},\"remappings\":[]},\"sources\":{\"solc_0.7/diamond/interfaces/IERC173.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n    /// @dev This emits when ownership of a contract changes.\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Get the address of the owner\\n    /// @return The address of the owner.\\n    function owner() external view returns (address);\\n\\n    /// @notice Set the address of the new owner of the contract\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external;\\n}\\n\",\"keccak256\":\"0xdb5c5f069a9337daa33b88c6c9fe72edb31b9ff91bf4a923caf02cb9e95d4b12\",\"license\":\"MIT\"}},\"version\":1}",
  "storageLayout": {
    "storage": [],
    "types": null
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "owner()": {
        "notice": "Get the address of the owner"
      },
      "transferOwnership(address)": {
        "notice": "Set the address of the new owner of the contract"
      }
    },
    "version": 1
  },
  "solcInput": "{\n  \"language\": \"Solidity\",\n  \"sources\": {\n    \"solc_0.7/diamond/Diamantaire.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./interfaces/IDiamondCut.sol\\\";\\nimport \\\"./Diamond.sol\\\";\\n\\ncontract Diamantaire {\\n    event DiamondCreated(Diamond diamond);\\n\\n    function createDiamond(\\n        address owner,\\n        IDiamondCut.Facet[] calldata _diamondCut,\\n        bytes calldata data,\\n        bytes32 salt\\n    ) external payable returns (Diamond diamond) {\\n        if (salt != 0x0000000000000000000000000000000000000000000000000000000000000000) {\\n            salt = keccak256(abi.encodePacked(salt, owner));\\n            diamond = new Diamond{value: msg.value, salt: salt}(address(this));\\n        } else {\\n            diamond = new Diamond{value: msg.value}(address(this));\\n        }\\n        emit DiamondCreated(diamond);\\n\\n        IDiamondCut(address(diamond)).diamondCut(_diamondCut, data.length > 0 ? address(diamond) : address(0), data);\\n        IERC173(address(diamond)).transferOwnership(owner);\\n    }\\n}\\n\"\n    },\n    \"solc_0.7/diamond/interfaces/IDiamondCut.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        Facet[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(Facet[] _diamondCut, address _init, bytes _calldata);\\n}\\n\"\n    },\n    \"solc_0.7/diamond/Diamond.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge\\n*\\n* Implementation of an example of a diamond.\\n/******************************************************************************/\\n\\nimport \\\"./libraries/LibDiamondStorage.sol\\\";\\nimport \\\"./libraries/LibDiamondCut.sol\\\";\\nimport \\\"./facets/OwnershipFacet.sol\\\";\\nimport \\\"./facets/DiamondCutFacet.sol\\\";\\nimport \\\"./facets/DiamondLoupeFacet.sol\\\";\\n\\ncontract Diamond {\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor(address owner) payable {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n        ds.contractOwner = owner;\\n        emit OwnershipTransferred(address(0), owner);\\n\\n        DiamondCutFacet diamondCutFacet = new DiamondCutFacet();\\n\\n        DiamondLoupeFacet diamondLoupeFacet = new DiamondLoupeFacet();\\n\\n        // Create a OwnershipFacet contract which implements the ERC-173 Ownership interface\\n        OwnershipFacet ownershipFacet = new OwnershipFacet();\\n\\n        IDiamondCut.Facet[] memory diamondCut = new IDiamondCut.Facet[](3);\\n\\n        // adding diamondCut function\\n        diamondCut[0].facetAddress = address(diamondCutFacet);\\n        diamondCut[0].functionSelectors = new bytes4[](1);\\n        diamondCut[0].functionSelectors[0] = DiamondCutFacet.diamondCut.selector;\\n\\n        // adding diamond loupe functions\\n        diamondCut[1].facetAddress = address(diamondLoupeFacet);\\n        diamondCut[1].functionSelectors = new bytes4[](5);\\n        diamondCut[1].functionSelectors[0] = DiamondLoupeFacet.facetFunctionSelectors.selector;\\n        diamondCut[1].functionSelectors[1] = DiamondLoupeFacet.facets.selector;\\n        diamondCut[1].functionSelectors[2] = DiamondLoupeFacet.facetAddress.selector;\\n        diamondCut[1].functionSelectors[3] = DiamondLoupeFacet.facetAddresses.selector;\\n        diamondCut[1].functionSelectors[4] = DiamondLoupeFacet.supportsInterface.selector;\\n\\n        // adding ownership functions\\n        diamondCut[2].facetAddress = address(ownershipFacet);\\n        diamondCut[2].functionSelectors = new bytes4[](2);\\n        diamondCut[2].functionSelectors[0] = OwnershipFacet.transferOwnership.selector;\\n        diamondCut[2].functionSelectors[1] = OwnershipFacet.owner.selector;\\n\\n        // execute non-standard internal diamondCut function to add functions\\n        LibDiamondCut.diamondCut(diamondCut);\\n\\n        // adding ERC165 data\\n        // ERC165\\n        ds.supportedInterfaces[IERC165.supportsInterface.selector] = true;\\n\\n        // DiamondCut\\n        ds.supportedInterfaces[DiamondCutFacet.diamondCut.selector] = true;\\n\\n        // DiamondLoupe\\n        bytes4 interfaceID = IDiamondLoupe.facets.selector ^\\n            IDiamondLoupe.facetFunctionSelectors.selector ^\\n            IDiamondLoupe.facetAddresses.selector ^\\n            IDiamondLoupe.facetAddress.selector;\\n        ds.supportedInterfaces[interfaceID] = true;\\n\\n        // ERC173\\n        ds.supportedInterfaces[IERC173.transferOwnership.selector ^ IERC173.owner.selector] = true;\\n    }\\n\\n    // Find facet for function that is called and execute the\\n    // function if a facet is found and return any value.\\n    fallback() external payable {\\n        LibDiamondStorage.DiamondStorage storage ds;\\n        bytes32 position = LibDiamondStorage.DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\\n        require(facet != address(0), \\\"Diamond: Function does not exist\\\");\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            switch result\\n                case 0 {\\n                    revert(0, returndatasize())\\n                }\\n                default {\\n                    return(0, returndatasize())\\n                }\\n        }\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\n    },\n    \"solc_0.7/diamond/libraries/LibDiamondStorage.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n/******************************************************************************/\\n\\nlibrary LibDiamondStorage {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint16 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint16 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // owner of the contract\\n        address contractOwner;\\n        // maps function selector to the facet address and        \\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n}\\n\"\n    },\n    \"solc_0.7/diamond/libraries/LibDiamondCut.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n*\\n* Implementation of internal diamondCut function.\\n/******************************************************************************/\\n\\nimport \\\"./LibDiamondStorage.sol\\\";\\nimport \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamondCut {\\n    event DiamondCut(IDiamondCut.Facet[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Non-standard internal function version of diamondCut\\n    // This code is almost the same as externalCut, except it is using\\n    // 'Facet[] memory _diamondCut' instead of 'Facet[] calldata _diamondCut'\\n    // and it DOES issue the DiamondCut event\\n    // The code is duplicated to prevent copying calldata to memory which\\n    // causes a Solidity error for a two dimensional array.\\n    function diamondCut(IDiamondCut.Facet[] memory _diamondCut) internal {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            address newFacetAddress = _diamondCut[facetIndex].facetAddress;\\n            // add or replace function\\n            if (newFacetAddress != address(0)) {\\n                uint256 facetAddressPosition = ds.facetFunctionSelectors[newFacetAddress].facetAddressPosition;\\n                // add new facet address if it does not exist\\n                if (facetAddressPosition == 0 && ds.facetFunctionSelectors[newFacetAddress].functionSelectors.length == 0) {\\n                    hasContractCode(newFacetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n                    facetAddressPosition = ds.facetAddresses.length;\\n                    ds.facetAddresses.push(newFacetAddress);\\n                    ds.facetFunctionSelectors[newFacetAddress].facetAddressPosition = uint16(facetAddressPosition);\\n                }\\n                // add or replace selectors\\n                for (uint256 selectorIndex; selectorIndex < _diamondCut[facetIndex].functionSelectors.length; selectorIndex++) {\\n                    bytes4 selector = _diamondCut[facetIndex].functionSelectors[selectorIndex];\\n                    address oldFacet = ds.selectorToFacetAndPosition[selector].facetAddress;\\n                    // add\\n                    if (oldFacet == address(0)) {\\n                        addSelector(newFacetAddress, selector);\\n                    } else {\\n                        // replace\\n                        if (oldFacet != newFacetAddress) {\\n                            removeSelector(selector);\\n                            addSelector(newFacetAddress, selector);\\n                        }\\n                    }\\n                }\\n            } else {\\n                // remove selectors\\n                for (uint256 selectorIndex; selectorIndex < _diamondCut[facetIndex].functionSelectors.length; selectorIndex++) {\\n                    removeSelector(_diamondCut[facetIndex].functionSelectors[selectorIndex]);\\n                }\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, address(0), new bytes(0));\\n    }\\n\\n    function addSelector(address _newFacet, bytes4 _selector) internal {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n        uint256 selectorPosition = ds.facetFunctionSelectors[_newFacet].functionSelectors.length;\\n        ds.facetFunctionSelectors[_newFacet].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _newFacet;\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = uint16(selectorPosition);\\n    }\\n\\n    function removeSelector(bytes4 _selector) internal {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n        address oldFacet = ds.selectorToFacetAndPosition[_selector].facetAddress;\\n        // if function does not exist then do nothing and return\\n        if (oldFacet == address(0)) {\\n            return;\\n        }\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[oldFacet].functionSelectors.length - 1;\\n        bytes4 lastSelector = ds.facetFunctionSelectors[oldFacet].functionSelectors[lastSelectorPosition];\\n        // if not the same then replace _selector with lastSelector\\n        if (lastSelector != _selector) {\\n            ds.facetFunctionSelectors[oldFacet].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint16(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[oldFacet].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[oldFacet].facetAddressPosition;\\n            if (oldFacet != lastFacetAddress) {\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = uint16(facetAddressPosition);\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[oldFacet];\\n        }\\n    }\\n\\n    function hasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\"\n    },\n    \"solc_0.7/diamond/facets/OwnershipFacet.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n/******************************************************************************/\\n\\nimport \\\"../libraries/LibDiamondStorage.sol\\\";\\nimport \\\"../interfaces/IERC173.sol\\\";\\n\\ncontract OwnershipFacet is IERC173 {\\n    function transferOwnership(address newOwner) external override {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n        address currentOwner = ds.contractOwner;\\n        require(msg.sender == currentOwner, \\\"Must own the contract.\\\");\\n        ds.contractOwner = newOwner;\\n        emit OwnershipTransferred(currentOwner, newOwner);\\n    }\\n\\n    function owner() external override view returns (address) {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n        return ds.contractOwner;\\n    }\\n}\\n\"\n    },\n    \"solc_0.7/diamond/facets/DiamondCutFacet.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n*\\n* Implementation of diamondCut external function.\\n/******************************************************************************/\\n\\nimport \\\"../libraries/LibDiamondStorage.sol\\\";\\nimport \\\"../interfaces/IDiamondCut.sol\\\";\\nimport \\\"../libraries/LibDiamondCut.sol\\\";\\n\\ncontract DiamondCutFacet is IDiamondCut {\\n    // Standard diamondCut external function\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        Facet[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external override {\\n        externalCut(_diamondCut);\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"DiamondCutFacet: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"DiamondCutFacet: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                LibDiamondCut.hasContractCode(_init, \\\"DiamondCutFacet: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"DiamondCutFacet: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    // diamondCut helper function\\n    // This code is almost the same as the internal diamondCut function,\\n    // except it is using 'Facets[] calldata _diamondCut' instead of\\n    // 'Facet[] memory _diamondCut', and it does not issue the DiamondCut event.\\n    // The code is duplicated to prevent copying calldata to memory which\\n    // causes a Solidity error for two dimensional arrays.\\n    function externalCut(Facet[] calldata _diamondCut) internal {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n        require(msg.sender == ds.contractOwner, \\\"Must own the contract.\\\");\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            address newFacetAddress = _diamondCut[facetIndex].facetAddress;\\n            // add or replace function\\n            if (newFacetAddress != address(0)) {\\n                uint256 facetAddressPosition = ds.facetFunctionSelectors[newFacetAddress].facetAddressPosition;\\n                // add new facet address if it does not exist\\n                if (facetAddressPosition == 0 && ds.facetFunctionSelectors[newFacetAddress].functionSelectors.length == 0) {\\n                    LibDiamondCut.hasContractCode(newFacetAddress, \\\"DiamondCutFacet: New facet has no code\\\");\\n                    facetAddressPosition = ds.facetAddresses.length;\\n                    ds.facetAddresses.push(newFacetAddress);\\n                    ds.facetFunctionSelectors[newFacetAddress].facetAddressPosition = uint16(facetAddressPosition);\\n                }\\n                // add or replace selectors\\n                for (uint256 selectorIndex; selectorIndex < _diamondCut[facetIndex].functionSelectors.length; selectorIndex++) {\\n                    bytes4 selector = _diamondCut[facetIndex].functionSelectors[selectorIndex];\\n                    address oldFacet = ds.selectorToFacetAndPosition[selector].facetAddress;\\n                    // add\\n                    if (oldFacet == address(0)) {\\n                        LibDiamondCut.addSelector(newFacetAddress, selector);\\n                    } else {\\n                        // replace\\n                        if (oldFacet != newFacetAddress) {\\n                            LibDiamondCut.removeSelector(selector);\\n                            LibDiamondCut.addSelector(newFacetAddress, selector);\\n                        }\\n                    }\\n                }\\n            } else {\\n                // remove selectors\\n                for (uint256 selectorIndex; selectorIndex < _diamondCut[facetIndex].functionSelectors.length; selectorIndex++) {\\n                    LibDiamondCut.removeSelector(_diamondCut[facetIndex].functionSelectors[selectorIndex]);\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\n    },\n    \"solc_0.7/diamond/facets/DiamondLoupeFacet.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n*\\n* Implementation of DiamondLoupe interface.\\n/******************************************************************************/\\n\\nimport \\\"../libraries/LibDiamondStorage.sol\\\";\\nimport \\\"../interfaces/IDiamondCut.sol\\\";\\nimport \\\"../interfaces/IDiamondLoupe.sol\\\";\\nimport \\\"../interfaces/IERC165.sol\\\";\\n\\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\\n    // Diamond Loupe Functions\\n    ////////////////////////////////////////////////////////////////////\\n    /// These functions are expected to be called frequently\\n    /// by tools. Therefore the return values are tightly\\n    /// packed for efficiency. That means no padding with zeros.\\n\\n    // struct Facet {\\n    //     address facetAddress;\\n    //     bytes4[] functionSelectors;\\n    // }\\n\\n    /// @notice Gets all facets and their selectors.\\n    /// @return facets_ Facet\\n    function facets() external override view returns (Facet[] memory facets_) {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n        uint256 numFacets = ds.facetAddresses.length;\\n        facets_ = new Facet[](numFacets);\\n        for (uint256 i; i < numFacets; i++) {\\n            address facetAddress = ds.facetAddresses[i];\\n            facets_[i].facetAddress = facetAddress;\\n            facets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress].functionSelectors;\\n        }\\n    }\\n\\n    /// @notice Gets all the function selectors provided by a facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet) external override view returns (bytes4[] memory facetFunctionSelectors_) {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n        facetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;\\n    }\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses() external override view returns (address[] memory facetAddresses_) {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n        facetAddresses_ = ds.facetAddresses;\\n    }\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector) external override view returns (address facetAddress_) {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n        facetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;\\n    }\\n\\n    // This implements ERC-165.\\n    function supportsInterface(bytes4 _interfaceId) external override view returns (bool) {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n        return ds.supportedInterfaces[_interfaceId];\\n    }\\n}\\n\"\n    },\n    \"solc_0.7/diamond/interfaces/IERC173.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n    /// @dev This emits when ownership of a contract changes.\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Get the address of the owner\\n    /// @return The address of the owner.\\n    function owner() external view returns (address);\\n\\n    /// @notice Set the address of the new owner of the contract\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external;\\n}\\n\"\n    },\n    \"solc_0.7/diamond/interfaces/IDiamondLoupe.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n/******************************************************************************/\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\n}\\n\"\n    },\n    \"solc_0.7/diamond/interfaces/IERC165.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\n    }\n  },\n  \"settings\": {\n    \"optimizer\": {\n      \"enabled\": true,\n      \"runs\": 2000\n    },\n    \"outputSelection\": {\n      \"*\": {\n        \"*\": [\n          \"abi\",\n          \"evm.bytecode\",\n          \"evm.deployedBytecode\",\n          \"evm.methodIdentifiers\",\n          \"metadata\",\n          \"devdoc\",\n          \"userdoc\",\n          \"storageLayout\",\n          \"evm.gasEstimates\"\n        ],\n        \"\": [\n          \"ast\"\n        ]\n      }\n    },\n    \"metadata\": {\n      \"useLiteralContent\": true\n    }\n  }\n}",
  "solcInputHash": "5a022ab8a5e62518819c0d82c6a35101"
}